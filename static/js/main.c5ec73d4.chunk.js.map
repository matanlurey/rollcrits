{"version":3,"sources":["app/state.ts","ui/Pool.tsx","app/simulation.ts","ui/Output/Breakdown.tsx","ui/Output.tsx","ui/Modifiers.tsx","ui/IterationSlider.tsx","ui/SeedInput.tsx","ui/Tokens.tsx","ui/Settings.tsx","app/App.tsx","index.tsx"],"names":["Prando","nextString","encodeConfig","config","btoa","JSON","stringify","DiceInput","props","Item","label","value","count","min","onChange","Number","isInteger","AttackDieSide","DefenseDieSide","Pool","dice","this","labelCol","xs","span","sm","red","v","updateDice","black","white","newPool","onChanged","React","Component","AttackDieType","crit","surge","hit","blank","DefenseDieType","block","AttackDie","sides","order","rng","nextArrayItem","DefenseDie","none","AttackBranch","result","modifiers","tokens","results","soFar","modify","critical","surgeTokens","optimizeFor","rerollDice","roll","i","length","shouldRerollHit","die","criticalLeft","against","willCancel","cover","defender","armor","Math","max","hits","impact","map","e","crits","aggregateHits","aims","aim","applyAimToken","precise","aggregateDice","convert","DefenseBranch","pierce","stats","Array","fill","blocks","generateDefenseDice","surges","Simulation","rngSeed","dicePool","pool","push","a","b","branches","iterations","generateAttackDice","d","sort","defending","name","compareFloats","parseFloat","woundsByCoverAmount","data","branch","wounds","expectedWounds","w","toFixed","key","unit","cover0","cover1","cover2","bordered","dataSource","pagination","size","title","dataIndex","sorter","compareStrings","render","query","hidden","showDefenderDetails","tags","color","style","transform","CaretDownOutlined","renderTags","simulate","grouped","ticks","Set","rawTotalHits","add","animate","duration","domainPadding","x","height","Object","entries","y","labels","datum","axisLabel","padding","mods","settings","Option","Select","slideToIterations","slider","App","defaultState","marks","1","3","5","toString","tipFormatter","maxLength","target","offset","icon","SyncOutlined","onClick","state","showModel","SettingFilled","ghost","setState","visible","onOk","onCancel","okText","checked","Sider","Layout","parse","fragment","urlState","window","location","hash","indexOf","substring","atob","decodeConfig","encodedState","defaultEncodedState","encodeStateIfChanged","minHeight","breakpoint","collapsedWidth","width","className","shortHash","SlidersOutlined","layout","IterationSlider","SeedInput","disabled","type","StarOutlined","newDice","EditOutlined","Modifiers","newModifiers","AppstoreOutlined","Tokens","newTokens","Content","margin","Output","freeze","marksman","dodge","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.c5ec73d4.chunk.js","sourcesContent":["import Prando from 'prando';\nimport { AttackDieSide } from './simulation';\n\nexport let sessionRngSeed = new Prando().nextString(10);\n\n/**\n * Simulation-wide state (or configuration).\n */\nexport interface AppConfig {\n  /**\n   * Attacking dice pool.\n   */\n  pool: AttackDiceConfig;\n\n  /**\n   * Attacking dice pool modifiers.\n   */\n  modifiers: AttackDiceModifiers;\n\n  /**\n   * Number of times the dice should be rolled.\n   */\n  iterations: number;\n\n  /**\n   * Random seed used for simulations.\n   */\n  rngSeed: string;\n\n  /**\n   * Application-wide settings.\n   */\n  settings: AppSettings;\n\n  /**\n   * Tokens available to spend.\n   */\n  tokens: AttackerTokens;\n}\n\nexport interface AppSettings {\n  showDefenderDetails: boolean;\n}\n\n/**\n * Encodes the provided configuration as base-64 encoded string.\n *\n * @param config\n */\nexport function encodeConfig(config: AppConfig): string {\n  return btoa(JSON.stringify(config));\n}\n\n/**\n * Decodes the provided hash-fragment URL into a config.\n *\n * Returns {undefined} if there was no stored configuration.\n */\nexport function decodeConfig(fragment: string): AppConfig | undefined {\n  let urlState = window.location.hash;\n  if (urlState) {\n    const fragment = urlState.indexOf('#');\n    if (fragment !== -1) {\n      urlState = urlState.substring(fragment + 1);\n    }\n    if (urlState && urlState.length && urlState !== 'default') {\n      return JSON.parse(atob(urlState));\n    }\n  }\n  return undefined;\n}\n\nexport interface AttackDiceConfig {\n  /**\n   * Number of red dice.\n   */\n  red: number;\n\n  /**\n   * Number of black dice.\n   */\n  black: number;\n\n  /**\n   * Number of white dice.\n   */\n  white: number;\n}\n\nexport interface AttackDiceModifiers {\n  /**\n   * How much critical the dice pool has.\n   */\n  critical: number;\n\n  /**\n   * How much impact the dice pool has.\n   */\n  impact: number;\n\n  /**\n   * Whether the pool has marksman.\n   */\n  marksman: boolean;\n\n  /**\n   * How much pierce the dice pool has.\n   */\n  pierce: number;\n\n  /**\n   * How many additional dice may be re-rolled during an aim.\n   */\n  precise: number;\n\n  /**\n   * What the `surge` icon the dice should convert to.\n   */\n  surge: AttackDieSide.blank | AttackDieSide.hit | AttackDieSide.crit;\n}\n\nexport interface AttackerTokens {\n  /**\n   * Aim tokens available.\n   */\n  aim: number;\n\n  /**\n   * Dodge tokens available.\n   */\n  dodge: number;\n\n  /**\n   * Surge tokens available.\n   */\n  surge: number;\n}\n","import React from 'react';\nimport { Form, InputNumber } from 'antd';\nimport { AttackDiceConfig } from '../app/state';\n\nfunction DiceInput(props: {\n  label: React.ReactNode;\n  count: number;\n  onChange: (count: number) => void;\n}) {\n  return (\n    <Form.Item label={props.label}>\n      <InputNumber\n        value={props.count}\n        min={0}\n        onChange={(value = 0) => {\n          props.onChange(Number.isInteger(value) ? value : props.count);\n        }}\n      ></InputNumber>\n    </Form.Item>\n  );\n}\n\nexport default class Pool extends React.Component<PoolProps> {\n  render() {\n    const dice = this.props.dice;\n    return (\n      <Form\n        labelCol={{\n          xs: { span: 24 },\n          sm: { span: 12 },\n        }}\n      >\n        <DiceInput\n          label=\"Red\"\n          count={dice.red}\n          onChange={(v: number) => this.updateDice({ red: v })}\n        />\n        <DiceInput\n          label=\"Black\"\n          count={dice.black}\n          onChange={(v: number) => this.updateDice({ black: v })}\n        />\n        <DiceInput\n          label=\"White\"\n          count={dice.white}\n          onChange={(v: number) => this.updateDice({ white: v })}\n        />\n      </Form>\n    );\n  }\n\n  updateDice(newPool: Partial<AttackDiceConfig>) {\n    this.props.onChanged({ ...this.props.dice, ...newPool });\n  }\n}\n\nexport interface PoolProps {\n  readonly dice: AttackDiceConfig;\n  readonly onChanged: (pool: AttackDiceConfig) => void;\n}\n","import Prando from 'prando';\nimport { AppConfig, AttackDiceModifiers, AttackerTokens } from './state';\n\n/**\n * Sides of an attack die.\n */\nexport enum AttackDieSide {\n  blank = 'blank',\n  surge = 'surge',\n  hit = 'hit',\n  crit = 'crit',\n}\n\n/**\n * Sides of a defense die.\n */\nexport enum DefenseDieSide {\n  blank = 'blank',\n  surge = 'surge',\n  block = 'block',\n}\n\n/**\n * Types of an attack die.\n */\nexport const AttackDieType = {\n  white: [\n    AttackDieSide.crit,\n    AttackDieSide.surge,\n    AttackDieSide.hit,\n    AttackDieSide.blank,\n    AttackDieSide.blank,\n    AttackDieSide.blank,\n    AttackDieSide.blank,\n    AttackDieSide.blank,\n  ],\n  black: [\n    AttackDieSide.crit,\n    AttackDieSide.surge,\n    AttackDieSide.hit,\n    AttackDieSide.hit,\n    AttackDieSide.hit,\n    AttackDieSide.blank,\n    AttackDieSide.blank,\n    AttackDieSide.blank,\n  ],\n  red: [\n    AttackDieSide.crit,\n    AttackDieSide.surge,\n    AttackDieSide.hit,\n    AttackDieSide.hit,\n    AttackDieSide.hit,\n    AttackDieSide.hit,\n    AttackDieSide.hit,\n    AttackDieSide.blank,\n  ],\n};\n\n/**\n * Types of a defense die.\n */\nexport const DefenseDieType = {\n  white: [\n    DefenseDieSide.block,\n    DefenseDieSide.surge,\n    DefenseDieSide.blank,\n    DefenseDieSide.blank,\n    DefenseDieSide.blank,\n    DefenseDieSide.blank,\n  ],\n\n  red: [\n    DefenseDieSide.block,\n    DefenseDieSide.block,\n    DefenseDieSide.block,\n    DefenseDieSide.surge,\n    DefenseDieSide.blank,\n    DefenseDieSide.blank,\n  ],\n};\n\n/**\n * Defines a single attack die.\n */\nexport class AttackDie {\n  static readonly red = new AttackDie(AttackDieType.red, 3);\n  static readonly black = new AttackDie(AttackDieType.black, 3);\n  static readonly white = new AttackDie(AttackDieType.white, 3);\n\n  private constructor(\n    private readonly sides: AttackDieSide[],\n    public readonly order: number,\n  ) {}\n\n  /**\n   * With the provided {rng}, changes the result of the die.\n   */\n  roll(rng: Prando): AttackDieSide {\n    return rng.nextArrayItem(this.sides);\n  }\n}\n\n/**\n * Defines a single defense die.\n */\nexport class DefenseDie {\n  static readonly red = new DefenseDie(DefenseDieType.red);\n  static readonly white = new DefenseDie(DefenseDieType.white);\n  static readonly none = new DefenseDie([DefenseDieSide.blank]);\n\n  private constructor(private readonly sides: DefenseDieSide[]) {}\n\n  /**\n   * With the provided {rng}, changes the result of the die.\n   */\n  roll(rng: Prando): DefenseDieSide {\n    return rng.nextArrayItem(this.sides);\n  }\n}\n\nexport interface DefenseStats {\n  /**\n   * Type of defense die\n   */\n  dice: DefenseDie;\n\n  /**\n   * Set if the die surge-side is considered a block.\n   */\n  surges?: true;\n\n  /**\n   * Set if numerical or unlimited armor.\n   */\n  armor?: number | true;\n\n  /**\n   * Set if immune to pierce or impervious to pierce.\n   */\n  pierce?: 'immune' | 'impervious';\n}\n\nexport class AttackBranch {\n  constructor(\n    private readonly rng: Prando,\n    private readonly result: Array<{ dice: AttackDie; roll: AttackDieSide }>,\n    private readonly modifiers: AttackDiceModifiers,\n    private readonly tokens: AttackerTokens,\n  ) {}\n\n  /**\n   * Mutates the provided array applying an \"aim\".\n   */\n  private applyAimToken(\n    results: Array<{ dice: AttackDie; roll: AttackDieSide }>,\n    soFar: { hits: number; crits: number },\n    modify: number,\n    critical: number,\n    surgeTokens: number,\n    optimizeFor?: {\n      cover: number;\n      defender: DefenseStats;\n    },\n  ): void {\n    const rerollDice = (result: { dice: AttackDie; roll: AttackDieSide }) => {\n      let roll = result.dice.roll(this.rng);\n\n      // TODO: Share code with aggregateDice.\n      if (roll === AttackDieSide.surge) {\n        if (critical) {\n          roll = AttackDieSide.crit;\n          critical--;\n        } else if (this.modifiers.surge !== 'blank' && surgeTokens) {\n          roll = AttackDieSide.hit;\n          surgeTokens--;\n        } else {\n          roll = this.modifiers.surge;\n        }\n      }\n\n      result.roll = roll;\n      modify--;\n    };\n\n    // Assume the results are sorted where it goes RBW. First roll all blanks.\n    for (let i = 0; i < results.length; i++) {\n      if (!modify) {\n        break;\n      }\n      switch (results[i].roll) {\n        // Always re-roll blanks. Conversions already applied.\n        case AttackDieSide.blank:\n          rerollDice(results[i]);\n          break;\n      }\n    }\n\n    // If we aren't just going for a vanity stat, we might want to roll crits.\n    if (optimizeFor) {\n      for (let i = 0; i < results.length; i++) {\n        if (!modify) {\n          break;\n        }\n        switch (results[i].roll) {\n          // Next, re-roll hits, sometimes.\n          case AttackDieSide.hit:\n            if (\n              this.shouldRerollHit(\n                results[i].dice,\n                critical,\n                soFar,\n                optimizeFor,\n              )\n            ) {\n              rerollDice(results[i]);\n            }\n            break;\n        }\n      }\n    }\n  }\n\n  // FYI: If we are entering this function, we have no blanks left.\n  private shouldRerollHit(\n    die: AttackDie,\n    criticalLeft: number,\n    soFar: { hits: number; crits: number },\n    against: { cover: number; defender: DefenseStats },\n  ): boolean {\n    // If we have already maxed out our impact against armor, re-roll for crits.\n    let willCancel = against.cover;\n    if (against.defender.armor === true) {\n      willCancel += Math.max(0, soFar.hits - this.modifiers.impact);\n    }\n\n    // If cover/armor would cancel all our hits, re-roll for crits.\n    if (willCancel >= soFar.hits) {\n      return true;\n    }\n\n    // TODO: This function is far from optimal, and very confusing.\n    return false;\n  }\n\n  private aggregateDice(optimizeFor?: {\n    cover: number;\n    defender: DefenseStats;\n  }): { hits: number; crits: number } {\n    // Make a copy of the results.\n    const results = this.result.map((e) => {\n      return {\n        dice: e.dice,\n        roll: e.roll,\n      };\n    });\n\n    // Count tokens.\n    let critical = this.modifiers.critical;\n    let surgeTokens = this.tokens.surge;\n\n    // Aggregate total hits and crits at this point.\n    let hits = 0;\n    let crits = 0;\n\n    // May be called to aggregate the total hits/crits.\n    const aggregateHits = () => {\n      hits = 0;\n      crits = 0;\n      for (const result of results) {\n        switch (result.roll) {\n          case AttackDieSide.crit:\n            crits++;\n            break;\n          case AttackDieSide.hit:\n            hits++;\n            break;\n        }\n      }\n    };\n\n    // Reverse order, apply surges/critical to our worst dice (white) first.\n    for (let i = results.length - 1; i >= 0; i--) {\n      const result = results[i];\n      let { roll } = result;\n\n      if (roll === AttackDieSide.surge) {\n        if (critical) {\n          roll = AttackDieSide.crit;\n          critical--;\n        } else if (this.modifiers.surge !== 'blank' && surgeTokens) {\n          roll = AttackDieSide.hit;\n          surgeTokens--;\n        } else {\n          roll = this.modifiers.surge;\n        }\n      }\n\n      result.roll = roll;\n    }\n\n    let aims = this.tokens.aim;\n    while (aims) {\n      // We'll need to know how many hits/crits so far.\n      aggregateHits();\n      this.applyAimToken(\n        results,\n        { hits, crits },\n        2 + this.modifiers.precise,\n        critical,\n        surgeTokens,\n        optimizeFor,\n      );\n      aims--;\n    }\n\n    // One final time.\n    aggregateHits();\n    return { hits, crits };\n  }\n\n  /**\n   * Returns the computed number of hits given cover and defense stats.\n   */\n  hits(cover: number, defender: DefenseStats): DefenseBranch {\n    let { hits, crits } = this.aggregateDice({\n      cover,\n      defender,\n    });\n\n    // Reduce hits by the amount of static cover, to a minimum of 0.\n    hits = Math.max(0, hits - cover);\n\n    // If `armor`, convert hits to crits, and deplete all or some hits.\n    if (defender.armor) {\n      const convert = Math.min(hits, this.modifiers.impact);\n      hits -= convert;\n      crits += convert;\n\n      if (defender.armor === true) {\n        // All non-converted hits are now cancelled.\n        hits = 0;\n      } else {\n        // Reduce hits by the amount of static armor, to a minimum of 0.\n        hits = Math.max(0, hits - defender.armor);\n      }\n    }\n\n    // Final number of dice that will need to be rolled for wounds.\n    // TODO: Consider returning multiple branches per attack.\n    return new DefenseBranch(\n      this.rng,\n      hits + crits,\n      defender,\n      this.modifiers.pierce,\n    );\n  }\n\n  get rawTotalHits(): number {\n    let { hits, crits } = this.aggregateDice();\n    return hits + crits;\n  }\n}\n\nexport class DefenseBranch {\n  constructor(\n    private readonly rng: Prando,\n    public readonly hits: number,\n    private readonly stats: DefenseStats,\n    private readonly pierce: number,\n  ) {}\n\n  /**\n   * Given the configuration, generates appropriate defense dice.\n   */\n  private generateDefenseDice(): DefenseDie[] {\n    let hits = this.hits;\n    if (this.stats.pierce === 'impervious') {\n      hits += this.pierce;\n    }\n    return Array(hits).fill(this.stats.dice);\n  }\n\n  /**\n   * Computes the number of wounds based on rolling defensive dice.\n   */\n  wounds(): number {\n    let blocks = 0;\n\n    for (const die of this.generateDefenseDice()) {\n      switch (die.roll(this.rng)) {\n        case DefenseDieSide.block:\n          blocks++;\n          break;\n        case DefenseDieSide.surge:\n          if (this.stats.surges) {\n            blocks++;\n          }\n          break;\n        case DefenseDieSide.blank:\n          break;\n      }\n    }\n\n    if (this.pierce && this.stats.pierce !== 'immune') {\n      blocks = Math.max(0, blocks - this.pierce);\n    }\n\n    // Future-proof against things like danger sense, a minimum of 0 wounds.\n    return Math.max(0, this.hits - blocks);\n  }\n}\n\n/**\n * Manages running the simulation from the top-down (as the root).\n */\nexport class Simulation {\n  private readonly rng: Prando;\n\n  constructor(private readonly config: AppConfig) {\n    this.rng = new Prando(config.rngSeed);\n  }\n\n  /**\n   * Given the configuration, generates appropriate attack dice.\n   */\n  private generateAttackDice(): AttackDie[] {\n    const results: AttackDie[] = [];\n    const dicePool = this.config.pool;\n    for (let i = 0; i < dicePool.red; i++) {\n      results.push(AttackDie.red);\n    }\n    for (let i = 0; i < dicePool.black; i++) {\n      results.push(AttackDie.black);\n    }\n    for (let i = 0; i < dicePool.white; i++) {\n      results.push(AttackDie.white);\n    }\n    return results;\n  }\n\n  private staticSortDice(a: AttackDie, b: AttackDie) {}\n\n  /**\n   * Returns possible results of the simulation.\n   */\n  simulate(): AttackBranch[] {\n    const branches: AttackBranch[] = Array(this.config.iterations);\n    for (let i = 0; i < branches.length; i++) {\n      // Roll dice.\n      const results = this.generateAttackDice()\n        .map((d) => {\n          return {\n            dice: d,\n            roll: d.roll(this.rng),\n          };\n        })\n        .sort((a, b) => a.dice.order - b.dice.order);\n\n      branches[i] = new AttackBranch(\n        this.rng,\n        results,\n        this.config.modifiers,\n        this.config.tokens,\n      );\n    }\n    return branches;\n  }\n}\n","import React from 'react';\nimport { Table, Row, Col, Tag } from 'antd';\nimport Media from 'react-media';\n\nimport './Breakdown.scss';\n\nimport * as stats from 'simple-statistics';\nimport { AttackBranch, DefenseDie, DefenseStats } from '../../app/simulation';\nimport ColumnGroup from 'antd/lib/table/ColumnGroup';\nimport Column from 'antd/lib/table/Column';\nimport { CaretDownOutlined } from '@ant-design/icons';\n\ninterface Defender extends DefenseStats {\n  name: string;\n}\n\n// TODO: Make customizable.\nconst defending: Defender[] = [\n  // Sample units.\n  { name: 'B1 Battle Droid', dice: DefenseDie.white },\n  { name: 'B2 Battle Droid', dice: DefenseDie.white, armor: 1 },\n  { name: 'Rebel Trooper', dice: DefenseDie.white, surges: true },\n  { name: 'Stormtrooper', dice: DefenseDie.red },\n  { name: 'Deathtrooper', dice: DefenseDie.red, surges: true },\n  {\n    name: 'Boba Fett',\n    dice: DefenseDie.red,\n    surges: true,\n    pierce: 'impervious',\n  },\n  { name: 'Darth Vader', dice: DefenseDie.red, pierce: 'immune' },\n  {\n    name: 'Emperor Palpatine',\n    dice: DefenseDie.red,\n    pierce: 'immune',\n    surges: true,\n  },\n  { name: 'Rebel AT-RT', dice: DefenseDie.white, armor: true },\n  {\n    name: 'X-34 Landpseeder',\n    dice: DefenseDie.white,\n    surges: true,\n    armor: 2,\n  },\n  { name: 'AT-ST', dice: DefenseDie.white, surges: true, armor: true },\n  { name: 'Dewback Rider', dice: DefenseDie.red, armor: 1 },\n  { name: 'Occupier Tank', dice: DefenseDie.red, armor: true },\n];\n\nfunction compareStrings(a: string, b: string) {\n  if (a > b) {\n    return 1;\n  }\n  if (a < b) {\n    return -1;\n  }\n  return 0;\n}\n\nfunction compareFloats(a: string, b: string) {\n  return Number.parseFloat(a) - Number.parseFloat(b);\n}\n\ninterface BreakdownProps {\n  mods: {\n    impact: number;\n  };\n  data: AttackBranch[];\n  showDefenderDetails: boolean;\n}\n\nexport default class extends React.Component<BreakdownProps> {\n  render() {\n    // Aggregate results per defending unit.\n    const results: Array<{\n      key: string;\n      unit: Defender;\n      cover0: string;\n      cover1: string;\n      cover2: string;\n    }> = [];\n\n    for (const defender of defending) {\n      let woundsByCoverAmount: number[][] = [[], [], []];\n\n      // For each amount of cover.\n      for (let cover = 0; cover < woundsByCoverAmount.length; cover++) {\n        // For each attacking dice pool.\n        for (const branch of this.props.data) {\n          // Add the number of expected wounds (v cover + defender).\n          woundsByCoverAmount[cover].push(\n            branch.hits(cover, defender).wounds(),\n          );\n        }\n      }\n\n      const expectedWounds = woundsByCoverAmount.map((w) =>\n        stats.mean(w).toFixed(2),\n      );\n\n      results.push({\n        key: defender.name,\n        unit: defender,\n        cover0: expectedWounds[0],\n        cover1: expectedWounds[1],\n        cover2: expectedWounds[2],\n      });\n    }\n\n    // Add the expected hits independent of the defending unit.\n    return (\n      <Table bordered dataSource={results} pagination={false} size={'small'}>\n        <Column\n          title=\"Defending Unit\"\n          dataIndex=\"unit\"\n          key=\"unit\"\n          sorter={(a: Defender, b: Defender) => compareStrings(a.name, b.name)}\n          render={(unit: Defender) => (\n            <Row>\n              <Col span={24}>{unit.name}</Col>\n              {/* TODO: Use conditional rendering instead. */}\n              <Media\n                query=\"(min-width: 499px)\"\n                render={() => (\n                  <Col span={24} hidden={!this.props.showDefenderDetails}>\n                    {renderTags(unit)}\n                  </Col>\n                )}\n              />\n            </Row>\n          )}\n        />\n        <ColumnGroup title=\"Cover\">\n          <Column\n            title=\"0\"\n            dataIndex=\"cover0\"\n            key=\"cover0\"\n            sorter={(a: string, b: string) => compareFloats(a, b)}\n          />\n          <Column\n            title=\"1\"\n            dataIndex=\"cover1\"\n            key=\"cover1\"\n            sorter={(a: string, b: string) => compareFloats(a, b)}\n          />\n          <Column\n            title=\"2\"\n            dataIndex=\"cover2\"\n            key=\"cover2\"\n            sorter={(a: string, b: string) => compareFloats(a, b)}\n          />\n        </ColumnGroup>\n      </Table>\n    );\n  }\n}\n\nfunction renderTags(defender: DefenseStats): React.ReactElement {\n  const tags: React.ReactElement[] = [\n    <Tag\n      color={defender.dice === DefenseDie.red ? 'red' : 'default'}\n      key=\"dice\"\n      style={{ transform: 'scale(0.5) rotate(45deg)' }}\n    >\n      &nbsp;\n    </Tag>,\n  ];\n  if (defender.surges) {\n    tags.push(\n      <Tag\n        color={defender.dice === DefenseDie.red ? 'red' : 'default'}\n        key=\"surges\"\n      >\n        Surge: <CaretDownOutlined /> {/* Infinity */}\n      </Tag>,\n    );\n  }\n  if (defender.pierce) {\n    if (defender.pierce === 'impervious') {\n      tags.push(\n        <Tag color=\"volcano\" key=\"pierce\">\n          <span>Impervious</span>\n        </Tag>,\n      );\n    } else {\n      tags.push(\n        <Tag color=\"volcano\" key=\"pierce\">\n          Immune: Pierce\n        </Tag>,\n      );\n    }\n  }\n  if (defender.armor) {\n    if (defender.armor === true) {\n      tags.push(\n        <Tag color=\"magenta\" key=\"armor\">\n          Armor: <strong>&#8734;</strong>\n        </Tag>,\n      );\n    } else {\n      tags.push(\n        <Tag color=\"magenta\" key=\"armor\">\n          Armor: {defender.armor}\n        </Tag>,\n      );\n    }\n  }\n  return <>{tags}</>;\n}\n","import React from 'react';\nimport { VictoryChart, VictoryBar, VictoryAxis } from 'victory';\nimport Breakdown from './Output/Breakdown';\nimport { AppConfig } from '../app/state';\nimport { Simulation } from '../app/simulation';\n\nexport default (props: { simulate: AppConfig }) => {\n  const data = new Simulation(props.simulate).simulate();\n  const grouped: { [key: number]: number } = {};\n  const ticks = new Set<number>();\n  for (const result of data) {\n    const hits = result.rawTotalHits;\n    grouped[hits] = (grouped[hits] || 0) + 1;\n    ticks.add(hits);\n  }\n  return (\n    <>\n      <VictoryChart\n        animate={{ duration: 1000 }}\n        domainPadding={{ x: 25 }}\n        height={200}\n      >\n        <VictoryBar\n          data={Object.entries(grouped).map((value) => {\n            return { x: value[0], y: value[1] };\n          })}\n          labels={({ datum }) =>\n            `${((datum.y / data.length) * 100).toFixed(0)}%`\n          }\n          style={{\n            data: {\n              fill: 'tomato',\n            },\n          }}\n        />\n        <VictoryAxis\n          style={{\n            axisLabel: { padding: 30 },\n          }}\n        />\n      </VictoryChart>\n      <Breakdown\n        data={data}\n        mods={{\n          impact: props.simulate.modifiers.impact,\n        }}\n        showDefenderDetails={props.simulate.settings.showDefenderDetails}\n      />\n    </>\n  );\n};\n","import React from 'react';\nimport { Form, Select, InputNumber, Divider } from 'antd';\nimport { AttackDiceModifiers } from '../app/state';\nimport { AttackDieSide } from '../app/simulation';\n\nconst { Option } = Select;\n\nexport default (props: {\n  modifiers: AttackDiceModifiers;\n  onChanged: (newModifiers: AttackDiceModifiers) => void;\n}) => {\n  return (\n    <Form\n      labelCol={{\n        xs: { span: 24 },\n        sm: { span: 12 },\n      }}\n    >\n      <Form.Item label=\"Surge\">\n        <Select\n          value={props.modifiers.surge}\n          onChange={(value) => {\n            props.onChanged({\n              ...props.modifiers,\n              surge: value,\n            });\n          }}\n        >\n          <Option value={AttackDieSide.blank}>None</Option>\n          <Option value={AttackDieSide.hit}>Hit</Option>\n          <Option value={AttackDieSide.crit}>Crit</Option>\n        </Select>\n      </Form.Item>\n      <Divider />\n      <Form.Item label=\"Critical\">\n        <InputNumber\n          value={props.modifiers.critical}\n          min={0}\n          onChange={(value) => {\n            props.onChanged({\n              ...props.modifiers,\n              critical: value === 0 ? 0 : value || props.modifiers.critical,\n            });\n          }}\n        />\n      </Form.Item>\n      <Form.Item label=\"Impact\">\n        <InputNumber\n          value={props.modifiers.impact}\n          min={0}\n          onChange={(value) => {\n            props.onChanged({\n              ...props.modifiers,\n              impact: value === 0 ? 0 : value || props.modifiers.impact,\n            });\n          }}\n        />\n      </Form.Item>\n      {/*\n        TODO: Enable.\n\n        <Form.Item label=\"Marksman\">\n          <Switch\n            checked={props.modifiers.marksman}\n            onChange={(value) => {\n              props.onChanged({\n                ...props.modifiers,\n                marksman: value,\n              });\n            }}\n          />\n        </Form.Item>\n      */}\n      <Form.Item label=\"Pierce\">\n        <InputNumber\n          value={props.modifiers.pierce}\n          min={0}\n          onChange={(value) => {\n            props.onChanged({\n              ...props.modifiers,\n              pierce: value === 0 ? 0 : value || props.modifiers.pierce,\n            });\n          }}\n        />\n      </Form.Item>\n      <Form.Item label=\"Precise\">\n        <InputNumber\n          value={props.modifiers.precise}\n          min={0}\n          onChange={(value) => {\n            props.onChanged({\n              ...props.modifiers,\n              precise: value === 0 ? 0 : value || props.modifiers.precise,\n            });\n          }}\n        />\n      </Form.Item>\n    </Form>\n  );\n};\n","import React from 'react';\nimport { Slider } from 'antd';\n\nimport App from '../app/App';\n\nfunction iterationsToSlider(iterations: number): number {\n  return iterations.toString().length - 1;\n}\n\nfunction slideToIterations(slider: number): number {\n  switch (slider) {\n    case 1:\n      return 10;\n    case 2:\n      return 100;\n    case 3:\n      return 1000;\n    case 4:\n      return 10000;\n    case 5:\n      return 100000;\n    default:\n      return App.defaultState.iterations;\n  }\n}\n\nexport default function (props: {\n  value: number;\n  onChanged: (value: number) => void;\n}) {\n  return (\n    <Slider\n      min={1}\n      max={5}\n      marks={{\n        1: '10',\n        3: '1000',\n        5: '100000',\n      }}\n      value={iterationsToSlider(props.value)}\n      tipFormatter={slideToIterations}\n      onChange={(value) => props.onChanged(slideToIterations(value as number))}\n    ></Slider>\n  );\n}\n","import React from 'react';\nimport { Row, Col, Input, Button } from 'antd';\nimport { SyncOutlined } from '@ant-design/icons';\nimport Prando from 'prando';\n\nexport default function (props: {\n  value: string;\n  onChanged: (value: string) => void;\n}) {\n  return (\n    <Row>\n      <Col span={18}>\n        <Input\n          value={props.value}\n          maxLength={10}\n          onChange={(v) => props.onChanged(v.target.value)}\n        />\n      </Col>\n      <Col span={2} offset={2}>\n        <Button\n          icon={<SyncOutlined />}\n          title=\"Randomize\"\n          onClick={() => props.onChanged(new Prando().nextString(10))}\n        />\n      </Col>\n    </Row>\n  );\n}\n","import React from 'react';\nimport { Form, InputNumber } from 'antd';\nimport { AttackerTokens } from '../app/state';\n\nexport default (props: {\n  tokens: AttackerTokens;\n  onChanged: (newModifiers: AttackerTokens) => void;\n}) => {\n  return (\n    <Form\n      labelCol={{\n        xs: { span: 24 },\n        sm: { span: 12 },\n      }}\n    >\n      <Form.Item label=\"Aim\">\n        <InputNumber\n          value={props.tokens.aim}\n          min={0}\n          onChange={(value) => {\n            props.onChanged({\n              ...props.tokens,\n              aim: value === 0 ? 0 : value || props.tokens.aim,\n            });\n          }}\n        />\n      </Form.Item>\n      <Form.Item label=\"Surge\">\n        <InputNumber\n          value={props.tokens.surge}\n          min={0}\n          onChange={(value) => {\n            props.onChanged({\n              ...props.tokens,\n              surge: value === 0 ? 0 : value || props.tokens.surge,\n            });\n          }}\n        />\n      </Form.Item>\n    </Form>\n  );\n};\n","import React from 'react';\nimport { SettingFilled } from '@ant-design/icons';\nimport { Button, Modal, Form, Switch } from 'antd';\nimport { AppSettings } from '../app/state';\n\ninterface SettingsProps {\n  settings: AppSettings;\n  onChange: (settings: AppSettings) => void;\n}\n\ninterface SettingsState {\n  showDefenderDetails: boolean;\n  showModel: boolean;\n}\n\nexport default class extends React.Component<SettingsProps, SettingsState> {\n  constructor(props: SettingsProps) {\n    super(props);\n    this.state = {\n      showDefenderDetails: props.settings.showDefenderDetails,\n      showModel: false,\n    };\n  }\n\n  render() {\n    return (\n      <>\n        <Button\n          icon={<SettingFilled />}\n          ghost\n          size=\"small\"\n          title=\"Settings\"\n          onClick={() => this.setState({ showModel: true })}\n        ></Button>\n        <Modal\n          visible={this.state.showModel}\n          onOk={() => {\n            this.setState({ showModel: false });\n            this.props.onChange({\n              showDefenderDetails: this.state.showDefenderDetails,\n            });\n          }}\n          onCancel={() =>\n            this.setState({\n              showModel: false,\n              showDefenderDetails: this.props.settings.showDefenderDetails,\n            })\n          }\n          okText=\"Save\"\n        >\n          <Form>\n            <Form.Item label=\"Show defender details\">\n              <Switch\n                checked={this.state.showDefenderDetails}\n                onChange={(value) => {\n                  this.setState({\n                    showDefenderDetails: value,\n                  });\n                }}\n              ></Switch>\n            </Form.Item>\n          </Form>\n        </Modal>\n      </>\n    );\n  }\n}\n","import React from 'react';\nimport GitInfo from 'react-git-info/macro';\nimport { Layout, Card, Form, Button, Row, Col } from 'antd';\nimport {\n  StarOutlined,\n  EditOutlined,\n  AppstoreOutlined,\n  SlidersOutlined,\n} from '@ant-design/icons';\n\nimport './App.scss';\n\nimport { AppConfig, encodeConfig, decodeConfig } from './state';\nimport Pool from '../ui/Pool';\nimport Output from '../ui/Output';\nimport Modifiers from '../ui/Modifiers';\nimport IterationSlider from '../ui/IterationSlider';\nimport Prando from 'prando';\nimport SeedInput from '../ui/SeedInput';\nimport { AttackDieSide } from './simulation';\nimport Tokens from '../ui/Tokens';\nimport Settings from '../ui/Settings';\n\nconst { Sider } = Layout;\n\nclass App extends React.Component<{}, AppConfig> {\n  public static readonly defaultState: AppConfig = Object.freeze({\n    pool: {\n      red: 1,\n      black: 1,\n      white: 1,\n    },\n    modifiers: {\n      critical: 0,\n      impact: 0,\n      marksman: false,\n      pierce: 0,\n      precise: 0,\n      surge: AttackDieSide.blank,\n    },\n    tokens: {\n      surge: 0,\n      aim: 0,\n      dodge: 0,\n    },\n    iterations: 10000,\n    rngSeed: `${new Prando().nextString(10)}`,\n    settings: {\n      showDefenderDetails: false,\n    },\n  });\n\n  private static readonly defaultEncodedState = encodeConfig(App.defaultState);\n  private static readonly shortHash = GitInfo().commit.shortHash;\n\n  constructor(props: {}) {\n    super(props);\n    const state = JSON.parse(JSON.stringify(App.defaultState));\n    this.state = { ...state, ...decodeConfig(window.location.hash) };\n  }\n\n  encodeStateIfChanged() {\n    const encodedState = encodeConfig(this.state);\n    if (encodedState === App.defaultEncodedState) {\n      window.location.hash = 'default';\n    } else {\n      window.location.hash = encodedState;\n    }\n  }\n\n  render() {\n    this.encodeStateIfChanged();\n    return (\n      <Layout style={{ minHeight: '100vh', height: '100%' }}>\n        <Sider\n          breakpoint=\"lg\"\n          collapsedWidth=\"0\"\n          width=\"250px\"\n          style={{ minHeight: '100vh', height: '100%' }}\n        >\n          <div className=\"logo\">\n            <Row>\n              <Col span={10}>\n                <strong>RollCrits</strong>\n              </Col>\n              <Col span={10}>#{App.shortHash}</Col>\n              <Col span={2}>\n                <Settings\n                  settings={this.state.settings}\n                  onChange={(settings) => {\n                    this.setState({ settings });\n                  }}\n                />\n              </Col>\n            </Row>\n          </div>\n          <Card\n            title={\n              <span>\n                <SlidersOutlined />\n                <span> Simulation</span>\n              </span>\n            }\n          >\n            <Form layout=\"vertical\">\n              <Form.Item label=\"Iterations\">\n                <IterationSlider\n                  value={this.state.iterations}\n                  onChanged={(value) => this.setState({ iterations: value })}\n                />\n              </Form.Item>\n              <Form.Item label=\"RNG Seed\">\n                <SeedInput\n                  value={this.state.rngSeed}\n                  onChanged={(value) => this.setState({ rngSeed: value })}\n                />\n              </Form.Item>\n              <Row>\n                <Col span={24}>\n                  <Button\n                    block\n                    disabled={window.location.hash === '#default'}\n                    type=\"danger\"\n                    onClick={() => {\n                      this.setState(App.defaultState);\n                    }}\n                  >\n                    Reset\n                  </Button>\n                </Col>\n              </Row>\n            </Form>\n          </Card>\n          <Card\n            title={\n              <span>\n                <StarOutlined />\n                <span> Dice</span>\n              </span>\n            }\n          >\n            <Pool\n              dice={this.state.pool}\n              onChanged={(newDice) => {\n                this.setState({\n                  pool: newDice,\n                });\n              }}\n            />\n          </Card>\n          <Card\n            title={\n              <span>\n                <EditOutlined />\n                <span> Modifiers</span>\n              </span>\n            }\n          >\n            <Modifiers\n              modifiers={this.state.modifiers}\n              onChanged={(newModifiers) => {\n                this.setState({\n                  modifiers: newModifiers,\n                });\n              }}\n            />\n          </Card>\n          <Card\n            title={\n              <span>\n                <AppstoreOutlined />\n                <span> Tokens</span>\n              </span>\n            }\n          >\n            <Tokens\n              tokens={this.state.tokens}\n              onChanged={(newTokens) => {\n                this.setState({\n                  tokens: newTokens,\n                });\n              }}\n            />\n          </Card>\n        </Sider>\n        <Layout>\n          <Layout.Content style={{ margin: '24px 16px 0' }}>\n            <div className=\"content-module\">\n              <Output simulate={this.state} />\n            </div>\n          </Layout.Content>\n        </Layout>\n      </Layout>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './app/App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}