{"version":3,"sources":["app/state.ts","ui/Pool.tsx","app/simulation.ts","ui/Output/Breakdown.tsx","ui/Output.tsx","ui/Modifiers.tsx","ui/IterationSlider.tsx","ui/SeedInput.tsx","ui/Tokens.tsx","app/App.tsx","index.tsx"],"names":["Prando","nextString","encodeConfig","config","btoa","JSON","stringify","DiceInput","props","Item","label","value","count","min","onChange","Number","isInteger","AttackDieSide","DefenseDieSide","Pool","dice","this","labelCol","xs","span","sm","red","v","updateDice","black","white","newPool","onChanged","React","Component","AttackDieType","crit","surge","hit","blank","DefenseDieType","block","AttackDie","sides","order","rng","nextArrayItem","DefenseDie","none","AttackBranch","result","modifiers","tokens","hits","crits","critical","surgeTokens","roll","cover","defender","aggregateDice","Math","max","armor","convert","impact","DefenseBranch","pierce","stats","Array","fill","blocks","generateDefenseDice","surges","Simulation","rngSeed","results","dicePool","pool","i","push","a","b","branches","iterations","length","generateAttackDice","map","d","sort","defending","name","compareFloats","parseFloat","state","showUnitStats","woundsByCoverAmount","data","branch","wounds","expectedWounds","w","toFixed","key","unit","cover0","cover1","cover2","bordered","dataSource","pagination","size","title","dataIndex","sorter","compareStrings","render","query","hidden","tags","color","style","transform","CaretDownOutlined","renderTags","simulate","grouped","ticks","Set","rawTotalHits","add","animate","duration","domainPadding","x","height","Object","entries","y","labels","datum","axisLabel","padding","mods","Option","Select","slideToIterations","slider","App","defaultState","marks","1","3","5","toString","tipFormatter","maxLength","target","offset","icon","SyncOutlined","onClick","Sider","Layout","parse","fragment","urlState","window","location","hash","indexOf","substring","atob","decodeConfig","encodedState","defaultEncodedState","encodeStateIfChanged","minHeight","breakpoint","collapsedWidth","width","className","shortHash","SettingOutlined","layout","IterationSlider","setState","SeedInput","disabled","type","StarOutlined","newDice","EditOutlined","Modifiers","newModifiers","AppstoreOutlined","Tokens","newTokens","Content","margin","Output","freeze","marksman","precise","aim","dodge","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.53ca7544.chunk.js","sourcesContent":["import Prando from 'prando';\nimport { AttackDieSide } from './simulation';\n\nexport let sessionRngSeed = new Prando().nextString(10);\n\n/**\n * Simulation-wide state (or configuration).\n */\nexport interface SimConfig {\n  /**\n   * Attacking dice pool.\n   */\n  pool: AttackDiceConfig;\n\n  /**\n   * Attacking dice pool modifiers.\n   */\n  modifiers: AttackDiceModifiers;\n\n  /**\n   * Number of times the dice should be rolled.\n   */\n  iterations: number;\n\n  /**\n   * Random seed used for simulations.\n   */\n  rngSeed: string;\n\n  /**\n   * Tokens available to spend.\n   */\n  tokens: AttackerTokens;\n}\n\n/**\n * Encodes the provided configuration as base-64 encoded string.\n *\n * @param config\n */\nexport function encodeConfig(config: SimConfig): string {\n  return btoa(JSON.stringify(config));\n}\n\n/**\n * Decodes the provided hash-fragment URL into a config.\n *\n * Returns {undefined} if there was no stored configuration.\n */\nexport function decodeConfig(fragment: string): SimConfig | undefined {\n  let urlState = window.location.hash;\n  if (urlState) {\n    const fragment = urlState.indexOf('#');\n    if (fragment !== -1) {\n      urlState = urlState.substring(fragment + 1);\n    }\n    if (urlState && urlState.length && urlState !== 'default') {\n      return JSON.parse(atob(urlState));\n    }\n  }\n  return undefined;\n}\n\nexport interface AttackDiceConfig {\n  /**\n   * Number of red dice.\n   */\n  red: number;\n\n  /**\n   * Number of black dice.\n   */\n  black: number;\n\n  /**\n   * Number of white dice.\n   */\n  white: number;\n}\n\nexport interface AttackDiceModifiers {\n  /**\n   * How much critical the dice pool has.\n   */\n  critical: number;\n\n  /**\n   * How much impact the dice pool has.\n   */\n  impact: number;\n\n  /**\n   * Whether the pool has marksman.\n   */\n  marksman: boolean;\n\n  /**\n   * How much pierce the dice pool has.\n   */\n  pierce: number;\n\n  /**\n   * How many additional dice may be re-rolled during an aim.\n   */\n  precise: number;\n\n  /**\n   * What the `surge` icon the dice should convert to.\n   */\n  surge: AttackDieSide.blank | AttackDieSide.hit | AttackDieSide.crit;\n}\n\nexport interface AttackerTokens {\n  /**\n   * Aim tokens available.\n   */\n  aim: number;\n\n  /**\n   * Dodge tokens available.\n   */\n  dodge: number;\n\n  /**\n   * Surge tokens available.\n   */\n  surge: number;\n}\n","import React from 'react';\nimport { Form, InputNumber } from 'antd';\nimport { AttackDiceConfig } from '../app/state';\n\nfunction DiceInput(props: {\n  label: React.ReactNode;\n  count: number;\n  onChange: (count: number) => void;\n}) {\n  return (\n    <Form.Item label={props.label}>\n      <InputNumber\n        value={props.count}\n        min={0}\n        onChange={(value = 0) => {\n          props.onChange(Number.isInteger(value) ? value : props.count);\n        }}\n      ></InputNumber>\n    </Form.Item>\n  );\n}\n\nexport default class Pool extends React.Component<PoolProps> {\n  render() {\n    const dice = this.props.dice;\n    return (\n      <Form\n        labelCol={{\n          xs: { span: 24 },\n          sm: { span: 12 },\n        }}\n      >\n        <DiceInput\n          label=\"Red\"\n          count={dice.red}\n          onChange={(v: number) => this.updateDice({ red: v })}\n        />\n        <DiceInput\n          label=\"Black\"\n          count={dice.black}\n          onChange={(v: number) => this.updateDice({ black: v })}\n        />\n        <DiceInput\n          label=\"White\"\n          count={dice.white}\n          onChange={(v: number) => this.updateDice({ white: v })}\n        />\n      </Form>\n    );\n  }\n\n  updateDice(newPool: Partial<AttackDiceConfig>) {\n    this.props.onChanged({ ...this.props.dice, ...newPool });\n  }\n}\n\nexport interface PoolProps {\n  readonly dice: AttackDiceConfig;\n  readonly onChanged: (pool: AttackDiceConfig) => void;\n}\n","import Prando from 'prando';\nimport { SimConfig, AttackDiceModifiers, AttackerTokens } from './state';\n\n/**\n * Sides of an attack die.\n */\nexport enum AttackDieSide {\n  blank = 'blank',\n  surge = 'surge',\n  hit = 'hit',\n  crit = 'crit',\n}\n\n/**\n * Sides of a defense die.\n */\nexport enum DefenseDieSide {\n  blank = 'blank',\n  surge = 'surge',\n  block = 'block',\n}\n\n/**\n * Types of an attack die.\n */\nexport const AttackDieType = {\n  white: [\n    AttackDieSide.crit,\n    AttackDieSide.surge,\n    AttackDieSide.hit,\n    AttackDieSide.blank,\n    AttackDieSide.blank,\n    AttackDieSide.blank,\n    AttackDieSide.blank,\n    AttackDieSide.blank,\n  ],\n  black: [\n    AttackDieSide.crit,\n    AttackDieSide.surge,\n    AttackDieSide.hit,\n    AttackDieSide.hit,\n    AttackDieSide.hit,\n    AttackDieSide.blank,\n    AttackDieSide.blank,\n    AttackDieSide.blank,\n  ],\n  red: [\n    AttackDieSide.crit,\n    AttackDieSide.surge,\n    AttackDieSide.hit,\n    AttackDieSide.hit,\n    AttackDieSide.hit,\n    AttackDieSide.hit,\n    AttackDieSide.hit,\n    AttackDieSide.blank,\n  ],\n};\n\n/**\n * Types of a defense die.\n */\nexport const DefenseDieType = {\n  white: [\n    DefenseDieSide.block,\n    DefenseDieSide.surge,\n    DefenseDieSide.blank,\n    DefenseDieSide.blank,\n    DefenseDieSide.blank,\n    DefenseDieSide.blank,\n  ],\n\n  red: [\n    DefenseDieSide.block,\n    DefenseDieSide.block,\n    DefenseDieSide.block,\n    DefenseDieSide.surge,\n    DefenseDieSide.blank,\n    DefenseDieSide.blank,\n  ],\n};\n\n/**\n * Defines a single attack die.\n */\nexport class AttackDie {\n  static readonly red = new AttackDie(AttackDieType.red, 3);\n  static readonly black = new AttackDie(AttackDieType.black, 3);\n  static readonly white = new AttackDie(AttackDieType.white, 3);\n\n  private constructor(\n    private readonly sides: AttackDieSide[],\n    public readonly order: number,\n  ) {}\n\n  /**\n   * With the provided {rng}, changes the result of the die.\n   */\n  roll(rng: Prando): AttackDieSide {\n    return rng.nextArrayItem(this.sides);\n  }\n}\n\n/**\n * Defines a single defense die.\n */\nexport class DefenseDie {\n  static readonly red = new DefenseDie(DefenseDieType.red);\n  static readonly white = new DefenseDie(DefenseDieType.white);\n  static readonly none = new DefenseDie([DefenseDieSide.blank]);\n\n  private constructor(private readonly sides: DefenseDieSide[]) {}\n\n  /**\n   * With the provided {rng}, changes the result of the die.\n   */\n  roll(rng: Prando): DefenseDieSide {\n    return rng.nextArrayItem(this.sides);\n  }\n}\n\nexport interface DefenseStats {\n  /**\n   * Type of defense die\n   */\n  dice: DefenseDie;\n\n  /**\n   * Set if the die surge-side is considered a block.\n   */\n  surges?: true;\n\n  /**\n   * Set if numerical or unlimited armor.\n   */\n  armor?: number | true;\n\n  /**\n   * Set if immune to pierce or impervious to pierce.\n   */\n  pierce?: 'immune' | 'impervious';\n}\n\nexport class AttackBranch {\n  constructor(\n    private readonly rng: Prando,\n    private readonly result: Array<{ dice: AttackDie; roll: AttackDieSide }>,\n    private readonly modifiers: AttackDiceModifiers,\n    private readonly tokens: AttackerTokens,\n  ) {}\n\n  private aggregateDice(): { hits: number; crits: number } {\n    let hits = 0;\n    let crits = 0;\n    let critical = this.modifiers.critical;\n    let surgeTokens = this.tokens.surge;\n\n    for (const result of this.result) {\n      let { roll } = result;\n\n      if (roll === AttackDieSide.surge) {\n        if (critical) {\n          roll = AttackDieSide.crit;\n          critical--;\n        } else if (this.modifiers.surge !== 'blank' && surgeTokens) {\n          roll = AttackDieSide.hit;\n          surgeTokens--;\n        } else {\n          roll = this.modifiers.surge;\n        }\n      }\n\n      // TODO: Implement aim tokens.\n\n      switch (roll) {\n        case AttackDieSide.crit:\n          crits++;\n          break;\n        case AttackDieSide.hit:\n          hits++;\n          break;\n        case AttackDieSide.blank:\n          break;\n      }\n    }\n\n    return { hits, crits };\n  }\n\n  /**\n   * Returns the computed number of hits given cover and defense stats.\n   */\n  hits(cover: number, defender: DefenseStats): DefenseBranch {\n    let { hits, crits } = this.aggregateDice();\n\n    // Reduce hits by the amount of static cover, to a minimum of 0.\n    hits = Math.max(0, hits - cover);\n\n    // If `armor`, convert hits to crits, and deplete all or some hits.\n    if (defender.armor) {\n      const convert = Math.min(hits, this.modifiers.impact);\n      hits -= convert;\n      crits += convert;\n\n      if (defender.armor === true) {\n        // All non-converted hits are now cancelled.\n        hits = 0;\n      } else {\n        // Reduce hits by the amount of static armor, to a minimum of 0.\n        hits = Math.max(0, hits - defender.armor);\n      }\n    }\n\n    // Final number of dice that will need to be rolled for wounds.\n    // TODO: Consider returning multiple branches per attack.\n    return new DefenseBranch(\n      this.rng,\n      hits + crits,\n      defender,\n      this.modifiers.pierce,\n    );\n  }\n\n  get rawTotalHits(): number {\n    let { hits, crits } = this.aggregateDice();\n    return hits + crits;\n  }\n}\n\nexport class DefenseBranch {\n  constructor(\n    private readonly rng: Prando,\n    public readonly hits: number,\n    private readonly stats: DefenseStats,\n    private readonly pierce: number,\n  ) {}\n\n  /**\n   * Given the configuration, generates appropriate defense dice.\n   */\n  private generateDefenseDice(): DefenseDie[] {\n    let hits = this.hits;\n    if (this.stats.pierce === 'impervious') {\n      hits += this.pierce;\n    }\n    return Array(hits).fill(this.stats.dice);\n  }\n\n  /**\n   * Computes the number of wounds based on rolling defensive dice.\n   */\n  wounds(): number {\n    let blocks = 0;\n\n    for (const die of this.generateDefenseDice()) {\n      switch (die.roll(this.rng)) {\n        case DefenseDieSide.block:\n          blocks++;\n          break;\n        case DefenseDieSide.surge:\n          if (this.stats.surges) {\n            blocks++;\n          }\n          break;\n        case DefenseDieSide.blank:\n          break;\n      }\n    }\n\n    if (this.pierce && this.stats.pierce !== 'immune') {\n      blocks = Math.max(0, blocks - this.pierce);\n    }\n\n    // Future-proof against things like danger sense, a minimum of 0 wounds.\n    return Math.max(0, this.hits - blocks);\n  }\n}\n\n/**\n * Manages running the simulation from the top-down (as the root).\n */\nexport class Simulation {\n  private readonly rng: Prando;\n\n  constructor(private readonly config: SimConfig) {\n    this.rng = new Prando(config.rngSeed);\n  }\n\n  /**\n   * Given the configuration, generates appropriate attack dice.\n   */\n  private generateAttackDice(): AttackDie[] {\n    const results: AttackDie[] = [];\n    const dicePool = this.config.pool;\n    for (let i = 0; i < dicePool.red; i++) {\n      results.push(AttackDie.red);\n    }\n    for (let i = 0; i < dicePool.black; i++) {\n      results.push(AttackDie.black);\n    }\n    for (let i = 0; i < dicePool.white; i++) {\n      results.push(AttackDie.white);\n    }\n    return results;\n  }\n\n  private staticSortDice(a: AttackDie, b: AttackDie) {}\n\n  /**\n   * Returns possible results of the simulation.\n   */\n  simulate(): AttackBranch[] {\n    const branches: AttackBranch[] = Array(this.config.iterations);\n    for (let i = 0; i < branches.length; i++) {\n      // Roll dice.\n      const results = this.generateAttackDice()\n        .map((d) => {\n          return {\n            dice: d,\n            roll: d.roll(this.rng),\n          };\n        })\n        .sort((a, b) => a.dice.order - b.dice.order);\n\n      branches[i] = new AttackBranch(\n        this.rng,\n        results,\n        this.config.modifiers,\n        this.config.tokens,\n      );\n    }\n    return branches;\n  }\n}\n","import React from 'react';\nimport { Table, Row, Col, Tag } from 'antd';\nimport Media from 'react-media';\n\nimport './Breakdown.scss';\n\nimport * as stats from 'simple-statistics';\nimport { AttackBranch, DefenseDie, DefenseStats } from '../../app/simulation';\nimport ColumnGroup from 'antd/lib/table/ColumnGroup';\nimport Column from 'antd/lib/table/Column';\nimport { CaretDownOutlined } from '@ant-design/icons';\n\ninterface Defender extends DefenseStats {\n  name: string;\n}\n\n// TODO: Make customizable.\nconst defending: Defender[] = [\n  // Sample units.\n  { name: 'B1 Battle Droid', dice: DefenseDie.white },\n  { name: 'B2 Battle Droid', dice: DefenseDie.white, armor: 1 },\n  { name: 'Rebel Trooper', dice: DefenseDie.white, surges: true },\n  { name: 'Stormtrooper', dice: DefenseDie.red },\n  { name: 'Deathtrooper', dice: DefenseDie.red, surges: true },\n  {\n    name: 'Boba Fett',\n    dice: DefenseDie.red,\n    surges: true,\n    pierce: 'impervious',\n  },\n  { name: 'Darth Vader', dice: DefenseDie.red, pierce: 'immune' },\n  {\n    name: 'Emperor Palpatine',\n    dice: DefenseDie.red,\n    pierce: 'immune',\n    surges: true,\n  },\n  { name: 'Rebel AT-RT', dice: DefenseDie.white, armor: true },\n  {\n    name: 'X-34 Landpseeder',\n    dice: DefenseDie.white,\n    surges: true,\n    armor: 2,\n  },\n  { name: 'AT-ST', dice: DefenseDie.white, surges: true, armor: true },\n  { name: 'Dewback Rider', dice: DefenseDie.red, armor: 1 },\n  { name: 'Occupier Tank', dice: DefenseDie.red, armor: true },\n];\n\nfunction compareStrings(a: string, b: string) {\n  if (a > b) {\n    return 1;\n  }\n  if (a < b) {\n    return -1;\n  }\n  return 0;\n}\n\nfunction compareFloats(a: string, b: string) {\n  return Number.parseFloat(a) - Number.parseFloat(b);\n}\n\ninterface BreakdownProps {\n  mods: {\n    impact: number;\n  };\n  data: AttackBranch[];\n}\n\ninterface BreakdownState {\n  showUnitStats: boolean;\n}\n\nexport default class extends React.Component<BreakdownProps, BreakdownState> {\n  constructor(props: BreakdownProps) {\n    super(props);\n    this.state = {\n      showUnitStats: true,\n    };\n  }\n\n  render() {\n    // Aggregate results per defending unit.\n    const results: Array<{\n      key: string;\n      unit: Defender;\n      cover0: string;\n      cover1: string;\n      cover2: string;\n    }> = [];\n\n    for (const defender of defending) {\n      let woundsByCoverAmount: number[][] = [[], [], []];\n\n      // For each amount of cover.\n      for (let cover = 0; cover < woundsByCoverAmount.length; cover++) {\n        // For each attacking dice pool.\n        for (const branch of this.props.data) {\n          // Add the number of expected wounds (v cover + defender).\n          woundsByCoverAmount[cover].push(\n            branch.hits(cover, defender).wounds(),\n          );\n        }\n      }\n\n      const expectedWounds = woundsByCoverAmount.map((w) =>\n        stats.mean(w).toFixed(2),\n      );\n\n      results.push({\n        key: defender.name,\n        unit: defender,\n        cover0: expectedWounds[0],\n        cover1: expectedWounds[1],\n        cover2: expectedWounds[2],\n      });\n    }\n\n    // Add the expected hits independent of the defending unit.\n    return (\n      <Table bordered dataSource={results} pagination={false} size={'small'}>\n        <Column\n          title=\"Defending Unit\"\n          dataIndex=\"unit\"\n          key=\"unit\"\n          sorter={(a: Defender, b: Defender) => compareStrings(a.name, b.name)}\n          render={(unit: Defender) => (\n            <Row>\n              <Col span={24}>{unit.name}</Col>\n              {/* TODO: Use conditional rendering instead. */}\n              <Media\n                query=\"(min-width: 499px)\"\n                render={() => (\n                  <Col span={24} hidden={!this.state.showUnitStats}>\n                    {renderTags(unit)}\n                  </Col>\n                )}\n              />\n            </Row>\n          )}\n        />\n        <ColumnGroup title=\"Cover\">\n          <Column\n            title=\"0\"\n            dataIndex=\"cover0\"\n            key=\"cover0\"\n            sorter={(a: string, b: string) => compareFloats(a, b)}\n          />\n          <Column\n            title=\"1\"\n            dataIndex=\"cover1\"\n            key=\"cover1\"\n            sorter={(a: string, b: string) => compareFloats(a, b)}\n          />\n          <Column\n            title=\"2\"\n            dataIndex=\"cover2\"\n            key=\"cover2\"\n            sorter={(a: string, b: string) => compareFloats(a, b)}\n          />\n        </ColumnGroup>\n      </Table>\n    );\n  }\n}\n\nfunction renderTags(defender: DefenseStats): React.ReactElement {\n  const tags: React.ReactElement[] = [\n    <Tag\n      color={defender.dice === DefenseDie.red ? 'red' : 'default'}\n      key=\"dice\"\n      style={{ transform: 'scale(0.5) rotate(45deg)' }}\n    >\n      &nbsp;\n    </Tag>,\n  ];\n  if (defender.surges) {\n    tags.push(\n      <Tag\n        color={defender.dice === DefenseDie.red ? 'red' : 'default'}\n        key=\"surges\"\n      >\n        Surge: <CaretDownOutlined /> {/* Infinity */}\n      </Tag>,\n    );\n  }\n  if (defender.pierce) {\n    if (defender.pierce === 'impervious') {\n      tags.push(\n        <Tag color=\"volcano\" key=\"pierce\">\n          <span>Impervious</span>\n        </Tag>,\n      );\n    } else {\n      tags.push(\n        <Tag color=\"volcano\" key=\"pierce\">\n          Immune: Pierce\n        </Tag>,\n      );\n    }\n  }\n  if (defender.armor) {\n    if (defender.armor === true) {\n      tags.push(\n        <Tag color=\"magenta\" key=\"armor\">\n          Armor: <strong>&#8734;</strong>\n        </Tag>,\n      );\n    } else {\n      tags.push(\n        <Tag color=\"magenta\" key=\"armor\">\n          Armor: {defender.armor}\n        </Tag>,\n      );\n    }\n  }\n  return <>{tags}</>;\n}\n","import React from 'react';\nimport { VictoryChart, VictoryBar, VictoryAxis } from 'victory';\nimport Breakdown from './Output/Breakdown';\nimport { SimConfig } from '../app/state';\nimport { Simulation } from '../app/simulation';\n\nexport default (props: { simulate: SimConfig }) => {\n  const data = new Simulation(props.simulate).simulate();\n  const grouped: { [key: number]: number } = {};\n  const ticks = new Set<number>();\n  for (const result of data) {\n    const hits = result.rawTotalHits;\n    grouped[hits] = (grouped[hits] || 0) + 1;\n    ticks.add(hits);\n  }\n  return (\n    <>\n      <VictoryChart\n        animate={{ duration: 1000 }}\n        domainPadding={{ x: 15 }}\n        height={200}\n      >\n        <VictoryBar\n          data={Object.entries(grouped).map((value) => {\n            return { x: value[0], y: value[1] };\n          })}\n          labels={({ datum }) =>\n            `${((datum.y / data.length) * 100).toFixed(0)}%`\n          }\n          style={{\n            data: {\n              fill: 'tomato',\n            },\n          }}\n        />\n        <VictoryAxis\n          style={{\n            axisLabel: { padding: 30 },\n          }}\n        />\n      </VictoryChart>\n      <Breakdown\n        data={data}\n        mods={{\n          impact: props.simulate.modifiers.impact,\n        }}\n      />\n    </>\n  );\n};\n","import React from 'react';\nimport { Form, Select, InputNumber, Divider } from 'antd';\nimport { AttackDiceModifiers } from '../app/state';\nimport { AttackDieSide } from '../app/simulation';\n\nconst { Option } = Select;\n\nexport default (props: {\n  modifiers: AttackDiceModifiers;\n  onChanged: (newModifiers: AttackDiceModifiers) => void;\n}) => {\n  return (\n    <Form\n      labelCol={{\n        xs: { span: 24 },\n        sm: { span: 12 },\n      }}\n    >\n      <Form.Item label=\"Surge\">\n        <Select\n          value={props.modifiers.surge}\n          onChange={(value) => {\n            props.onChanged({\n              ...props.modifiers,\n              surge: value,\n            });\n          }}\n        >\n          <Option value={AttackDieSide.blank}>None</Option>\n          <Option value={AttackDieSide.hit}>Hit</Option>\n          <Option value={AttackDieSide.crit}>Crit</Option>\n        </Select>\n      </Form.Item>\n      <Divider />\n      <Form.Item label=\"Critical\">\n        <InputNumber\n          value={props.modifiers.critical}\n          min={0}\n          onChange={(value) => {\n            props.onChanged({\n              ...props.modifiers,\n              critical: value === 0 ? 0 : value || props.modifiers.critical,\n            });\n          }}\n        />\n      </Form.Item>\n      <Form.Item label=\"Impact\">\n        <InputNumber\n          value={props.modifiers.impact}\n          min={0}\n          onChange={(value) => {\n            props.onChanged({\n              ...props.modifiers,\n              impact: value === 0 ? 0 : value || props.modifiers.impact,\n            });\n          }}\n        />\n      </Form.Item>\n      {/*\n        TODO: Enable.\n\n        <Form.Item label=\"Marksman\">\n          <Switch\n            checked={props.modifiers.marksman}\n            onChange={(value) => {\n              props.onChanged({\n                ...props.modifiers,\n                marksman: value,\n              });\n            }}\n          />\n        </Form.Item>\n      */}\n      <Form.Item label=\"Pierce\">\n        <InputNumber\n          value={props.modifiers.pierce}\n          min={0}\n          onChange={(value) => {\n            props.onChanged({\n              ...props.modifiers,\n              pierce: value === 0 ? 0 : value || props.modifiers.pierce,\n            });\n          }}\n        />\n      </Form.Item>\n      {/*\n        TODO: Enable aim tokens.\n\n        <Form.Item label=\"Precise\">\n          <InputNumber\n            value={props.modifiers.precise}\n            min={0}\n            onChange={(value) => {\n              props.onChanged({\n                ...props.modifiers,\n                precise: value === 0 ? 0 : value || props.modifiers.precise,\n              });\n            }}\n          />\n        </Form.Item>\n      */}\n    </Form>\n  );\n};\n","import React from 'react';\nimport { Slider } from 'antd';\n\nimport App from '../app/App';\n\nfunction iterationsToSlider(iterations: number): number {\n  return iterations.toString().length - 1;\n}\n\nfunction slideToIterations(slider: number): number {\n  switch (slider) {\n    case 1:\n      return 10;\n    case 2:\n      return 100;\n    case 3:\n      return 1000;\n    case 4:\n      return 10000;\n    case 5:\n      return 100000;\n    default:\n      return App.defaultState.iterations;\n  }\n}\n\nexport default function (props: {\n  value: number;\n  onChanged: (value: number) => void;\n}) {\n  return (\n    <Slider\n      min={1}\n      max={5}\n      marks={{\n        1: '10',\n        3: '1000',\n        5: '100000',\n      }}\n      value={iterationsToSlider(props.value)}\n      tipFormatter={slideToIterations}\n      onChange={(value) => props.onChanged(slideToIterations(value as number))}\n    ></Slider>\n  );\n}\n","import React from 'react';\nimport { Row, Col, Input, Button } from 'antd';\nimport { SyncOutlined } from '@ant-design/icons';\nimport Prando from 'prando';\n\nexport default function (props: {\n  value: string;\n  onChanged: (value: string) => void;\n}) {\n  return (\n    <Row>\n      <Col span={18}>\n        <Input\n          value={props.value}\n          maxLength={10}\n          onChange={(v) => props.onChanged(v.target.value)}\n        />\n      </Col>\n      <Col span={2} offset={2}>\n        <Button\n          icon={<SyncOutlined />}\n          title=\"Randomize\"\n          onClick={() => props.onChanged(new Prando().nextString(10))}\n        />\n      </Col>\n    </Row>\n  );\n}\n","import React from 'react';\nimport { Form, InputNumber } from 'antd';\nimport { AttackerTokens } from '../app/state';\n\nexport default (props: {\n  tokens: AttackerTokens;\n  onChanged: (newModifiers: AttackerTokens) => void;\n}) => {\n  return (\n    <Form\n      labelCol={{\n        xs: { span: 24 },\n        sm: { span: 12 },\n      }}\n    >\n      {/*\n        TODO: Enable aim tokens.\n\n        <Form.Item label=\"Aim\">\n          <InputNumber\n            value={props.tokens.aim}\n            min={0}\n            onChange={(value) => {\n              props.onChanged({\n                ...props.tokens,\n                aim: value === 0 ? 0 : value || props.tokens.aim,\n              });\n            }}\n          />\n        </Form.Item>\n      */}\n      <Form.Item label=\"Surge\">\n        <InputNumber\n          value={props.tokens.surge}\n          min={0}\n          onChange={(value) => {\n            props.onChanged({\n              ...props.tokens,\n              surge: value === 0 ? 0 : value || props.tokens.surge,\n            });\n          }}\n        />\n      </Form.Item>\n    </Form>\n  );\n};\n","import React from 'react';\nimport GitInfo from 'react-git-info/macro';\nimport { Layout, Card, Form, Button, Row, Col } from 'antd';\nimport {\n  SettingOutlined,\n  StarOutlined,\n  EditOutlined,\n  AppstoreOutlined,\n} from '@ant-design/icons';\n\nimport './App.scss';\n\nimport { SimConfig, encodeConfig, decodeConfig } from './state';\nimport Pool from '../ui/Pool';\nimport Output from '../ui/Output';\nimport Modifiers from '../ui/Modifiers';\nimport IterationSlider from '../ui/IterationSlider';\nimport Prando from 'prando';\nimport SeedInput from '../ui/SeedInput';\nimport { AttackDieSide } from './simulation';\nimport Tokens from '../ui/Tokens';\n\nconst { Sider } = Layout;\n\nclass App extends React.Component<{}, SimConfig> {\n  public static readonly defaultState: SimConfig = Object.freeze({\n    pool: {\n      red: 1,\n      black: 1,\n      white: 1,\n    },\n    modifiers: {\n      critical: 0,\n      impact: 0,\n      marksman: false,\n      pierce: 0,\n      precise: 0,\n      surge: AttackDieSide.blank,\n    },\n    tokens: {\n      surge: 0,\n      aim: 0,\n      dodge: 0,\n    },\n    iterations: 10000,\n    rngSeed: `${new Prando().nextString(10)}`,\n  });\n\n  private static readonly defaultEncodedState = encodeConfig(App.defaultState);\n  private static readonly shortHash = GitInfo().commit.shortHash;\n\n  constructor(props: {}) {\n    super(props);\n    const state = JSON.parse(JSON.stringify(App.defaultState));\n    this.state = { ...state, ...decodeConfig(window.location.hash) };\n  }\n\n  encodeStateIfChanged() {\n    const encodedState = encodeConfig(this.state);\n    if (encodedState === App.defaultEncodedState) {\n      window.location.hash = 'default';\n    } else {\n      window.location.hash = encodedState;\n    }\n  }\n\n  render() {\n    this.encodeStateIfChanged();\n    return (\n      <Layout style={{ minHeight: '100vh', height: '100%' }}>\n        <Sider\n          breakpoint=\"lg\"\n          collapsedWidth=\"0\"\n          width=\"250px\"\n          style={{ minHeight: '100vh', height: '100%' }}\n        >\n          <div className=\"logo\">\n            <strong>RollCrits</strong> #{App.shortHash}\n          </div>\n          <Card\n            title={\n              <span>\n                <SettingOutlined />\n                <span> Settings</span>\n              </span>\n            }\n          >\n            <Form layout=\"vertical\">\n              <Form.Item label=\"Iterations\">\n                <IterationSlider\n                  value={this.state.iterations}\n                  onChanged={(value) => this.setState({ iterations: value })}\n                />\n              </Form.Item>\n              <Form.Item label=\"RNG Seed\">\n                <SeedInput\n                  value={this.state.rngSeed}\n                  onChanged={(value) => this.setState({ rngSeed: value })}\n                />\n              </Form.Item>\n              <Row>\n                <Col span={24}>\n                  <Button\n                    block\n                    disabled={window.location.hash === '#default'}\n                    type=\"danger\"\n                    onClick={() => {\n                      this.setState(App.defaultState);\n                    }}\n                  >\n                    Reset\n                  </Button>\n                </Col>\n              </Row>\n            </Form>\n          </Card>\n          <Card\n            title={\n              <span>\n                <StarOutlined />\n                <span> Dice</span>\n              </span>\n            }\n          >\n            <Pool\n              dice={this.state.pool}\n              onChanged={(newDice) => {\n                this.setState({\n                  pool: newDice,\n                });\n              }}\n            />\n          </Card>\n          <Card\n            title={\n              <span>\n                <EditOutlined />\n                <span> Modifiers</span>\n              </span>\n            }\n          >\n            <Modifiers\n              modifiers={this.state.modifiers}\n              onChanged={(newModifiers) => {\n                this.setState({\n                  modifiers: newModifiers,\n                });\n              }}\n            />\n          </Card>\n          <Card\n            title={\n              <span>\n                <AppstoreOutlined />\n                <span> Tokens</span>\n              </span>\n            }\n          >\n            <Tokens\n              tokens={this.state.tokens}\n              onChanged={(newTokens) => {\n                this.setState({\n                  tokens: newTokens,\n                });\n              }}\n            />\n          </Card>\n        </Sider>\n        <Layout>\n          <Layout.Content style={{ margin: '24px 16px 0' }}>\n            <div className=\"content-module\">\n              <Output simulate={this.state} />\n            </div>\n          </Layout.Content>\n        </Layout>\n      </Layout>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './app/App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}